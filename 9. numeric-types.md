
# Numeric Types

In Python, numbers are not a single object type, but a category of similer types.
Python supports the usual numeric types (integers and floating points), as well as literals for creating 
numbers and expressions for processing them. In addition, Python provides more advanced numeric programming
support and objects for more advanced work.

**A complete inventory of Python's numeric toolbox includes:**

- Integer and floating-point objects
- Complex number objects
- Decimal: fixed precision objects
- Fraction: rational number objects
- Sets: collections with numeric operations
- Booleans: true and false
- Build-in functions and modules: round, math, random, etc.
- Expressions; unlimited integer precision; bitwise operations; hex, octal, and binary formats
- Third-party extensions: vectors, libraries, visualization, plotting, etc.

## Numeric Literals

| Literals | interpretation |
|----------|----------------|
| 1234, -24, 0, 99999999999999 | Integers (unlimited size) |
| 1.23, 1., 3.14e-10, 4E210, 4.0e+210 | Floating-point numbers |
| 0o177, 0x9ff, 0b101010 | Octal, hex, and binary literals |
| 3+4j, 3.0+4.0j, 3J | Complex number literals |
| set('spam'), {1, 2, 3, 4} | Sets: construction forms |
| Decimal('1.0'), Fraction(1, 3) | Decimal and fraction extension types |
| bool(X), True, False | Boolean type and constants |

> ### Complex numbers
>
> Python complex literals are written as ***realpart+imaginarypart***, where the imaginarypart is terminated with a **j** or **J**. The ***realpart*** is technically optional, so the ***imaginarypart*** may appear on its own.Internally, complex numbers are implemented as pairs of floating-point numbers, but all numeric operations perform complex math when applied to complex numbers. 
>
> Complex numbers may also be created with the `complex(real, imag)` built-in call.

## Build-in Numeric Tools

#### Python provides a set of tools for processing number objects:

*Expression operators*: `+`, `-`, `*`, `/`, `>>`, `**`, `&`, __etc.__

*Build-in mathematical functions*: `pow`, `abs`, `round`, `int`, `hex`, `bin`, __etc.__

*Utility modules*: `random`, `math`, __etc.__


## Python expression operators and precedence

| Operators | Description |
|-----------|-------------|
| `yield x` | Generator function send protocol |
| `lambda args: expression` | Anonymous function generation |
| `x if y else z` | Ternary selection (x is evaluated only if y is true) |
| `x or y` | Logical OR (y is evaluated only if x is false) |
| `x and y` | Logical AND (y is evaluated only if x is true) |
| `not x` | Logical negation |
| `x in y, x not in y` | Membership (iterables, sets) |
| `x is y, x is not y` | Object identity tests |
| `x < y`, `x <= y`, `x > y`, `x >= y` | Magnitude comparison, set subset and superset; |
| `x == y`, `x != y` | Value equality operators |
| `x \| y` | Bitwise OR, set union |
| `x ^ y` | Bitwise XOR, set symmetric difference |
| `x & y` | Bitwise AND, set intersection |
| `x << y`, `x >> y` | Shift x left or right by y bits |
| `x + y` | Addition, concatenation; |
| `x – y` | Subtraction, set difference |
| `x * y` | Multiplication, repetition; |
| `x % y` | Remainder, format; |
| `x / y`, `x // y` | Division: true and floor |
| `−x`, `+x` | Negation, identity |
| `˜x` | Bitwise NOT (inversion) |
| `x ** y` | Power (exponentiation) |
| `x[i]` | Indexing (sequence, mapping, others) |
| `x[i:j:k]` | Slicing |
| `x(...)` | Call (function, method, class, other callable) |
| `x.attr` | Attribute reference |
| `(...)` | Tuple, expression, generator expression |
| `[...]` | List, list comprehension |
| `{...}` | Dictionary, set, set and dictionary comprehensions |


> Operators lower in the table have higher precedence, and so blind more tighly in mixed expression.
>
> Operators in the same row in the table generally group from left to right when combined (except for exponentiation, which groups right to left, and comparisons, which chain left to right).


### Mixed operators follow operator precedence

When you write an expression with more than one operator, Python groups it's parts according to what are called *Precedence rules*, and this grouping determines the order in which the expression's parts are computed.

## Comparisons 

Python allows us to *chain* mutiple comparisons together to perform range tests. Chained comparisons are a sort of shorthand for boolean expressions.

> For instance, the expression **`(A < B < C)`** tests whether **`B`** is between **`A`** and **`C`**.  
It's equivalent to the boolean test **`(A < B and B < C)`**.


```python
X = 2
Y = 4
Z = 6

print(X < Y < Z) #Output: True

print(1 == 2 < 3) #Output: False
#Not same as: False < 3 (Which means 0 < 3, which is true)
```

## Division

- ***True division***: In Python 3.X, it performs *true* division, always keeping remainders in floating-point results, regardless of types.

```python
X = 5
Y = 2

print(X / Y) #Output: 2.5
```

- ***Floor division***: The // operator is informally called *trucating* division, but it's more accurate to refer to it as *floor* division. It truncates fractional remainders down to their floor, reguardless of types. Its result type depends on the types of its operands.

```python
X = 5
Y = 2

print(X // Y) #Output: 2
```

### Floor vs Truncation

The *floor* division truncates the result down to its floor, which means the closest whole number below the true result. The net effect is to round down, not strictly truncate, and this matters for negetives.

```python
import math

# floor() : Closest number below the true value

print(math.floor(2.5)) # Output: 2

print(math.floor(-2.5)) # Output: -3

# trunc() : Truncate fractional part (towards zero)

print(math.trunc(2.5)) # Output: 2

print(math.trunc(-2.5)) # Output: -2
```

> ### If you face trouble to understand the above example the table below will help
>
>| `-3` | `-2.5` | `-2` | -1.5 | -1 | -0.5 | `0` | 0.5 | 1 | 1.5 | `2` | `2.5` | 3 |  
>|------|--------|------|------|----|------|-----|-----|---|-----|-----|-------|---|


### Why does trucation matter

```python
# True division
print(5 / 2) # Output: 2.5
print(5 / 2.0) # Output: 2.5
print(5 / -2.0) # Output: -2.5
print(5 / -2) # Output: -2.5

# Floor division
print(5 // 2) # Output: 2
print(5 // 2.0) # Output: 2.0
print(5 // -2.0) # Output: -3.0
print(5 // -2) # Output: -3
```

## Hex, Octal, Binary: Literals and Conversions

Python integers can be coded in hexadecimal, octal and binary notation. Keep in mind that these lierals are simply an alternative syntax for specifying the value of an integer object.  

>For example, the following literals produce normal integers with the specified values in all three bases. In memory, an integer's value is the same, regardless of the base we use to specify it.

```python
# Octal literals: base 8; digits: 0-7

print(0o1) # Output: 1
print(0o20) # Output: 16
print(0o377) # Output: 255

# Hex literals: base 16; digits: 0-9 / A-F

print(0x1) # Output: 1
print(0x10) # Output: 16
print(0xFF) # Output: 255

#Binary literals: base 2; digits: 0-1

print(0b1) # Output: 1
print(0b10000) # Output: 16
print(0b11111111) # Output: 255
```

Python prints integer values in decimal (base 10) by default but provides build-in functions that allow you to convert integers to other bases digit strings.

```python
# Decimal to Octal
print(oct(20)) # Output: '0o24'

# Decimal to Hex
print(hex(15)) # Output: '0xF'

# Decimal to Binary
print(bin(32)) # Output: '0b100000'
```

The above build-in functions converts decimal to octal, hex and decimal depending on what function you use, but all these function returns the converted result into string.  

To go the other way, the build-in funcion `int()` converts string of digits to integers, and an optional second argument lets you specify the numeric base.

```python
print(int('100', 8)) # Output: 64
print(int('40', 16)) # Output: 64
print(int('1000000', 2)) # Output: 64

# Literal forms are supported too

print(int('0x40', 16)) # Output: 64
print(int('0b1000000', 2)) # Output: 64
```

The `eval()` function, treats strings as though they were Python code. Therefore, it has similer effect, but usually runs more *slowly*.

```python
print(eval('0xFF')) # Output: 255
```

Finally, you can also convert integers to base-specific strings with *string formating* method calls and expressions, which return just digits, not Python literal strings.

```python
conversion = '{0:o}, {1:x}, {2:b}'.format(64, 64, 64)

print(conversion) # Output: 100, 40, 1000000

conversion = '%o, %x, %x, %X' % (64, 64, 255, 255)

print(conversion) # Output: 100, 40, ff, FF
```

## Bitwise Operations

